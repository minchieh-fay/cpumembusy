# cpumembusy

让机器的资源看上去忙碌

## 背景

领导们视察集群，消耗服务器资源太少，需要有个服务来占用 CPU 和内存。

## 技术栈

- Go

## 构建

使用 `build.sh` 脚本编译 Linux x86_64 版本：

```bash
chmod +x build.sh
./build.sh
```

编译完成后会生成 `cpumembusy` 二进制文件。

**注意**：本工程不包含 Dockerfile，Docker 镜像制作将在其他工程中完成。

## 功能说明

这个机器本身也可能会有业务使用，所以我们不能乱用 CPU 和内存。

### 核心需求

1. **业务共存**：这个机器跑着其他正常使用的业务，需要避免影响正常业务

2. **资源波动算法**：
   - 采用趋势性算法，基于当前整机占用率和期望占用率的差值，概率性地调整资源占用
   - **波动周期**：随机间隔 5-10 秒执行一次调整（避免周期性行为过于明显）
   - **期望占用值计算**：
     - 凌晨时段（UTC 16:00-20:00）：期望占用 = min(用户设置值, 70%)
     - 其他时段：期望占用 = min(用户设置值 * 0.8, 70%)
   - **内存控制算法**：
     - 每次操作调整 0.1% 的内存（相对于整机总内存）
     - 程序通过分配/释放自己的内存来影响整机内存占用
     - **概率计算**（基于当前占用与期望占用的差值）：
       - 如果差值 > 5%：调整概率为 90%
       - 如果差值 2%-5%：调整概率为 70%
       - 如果差值 < 2%（接近期望）：调整概率为 60%，且增加的概率（55%）略大于减少的概率（45%）
   - **CPU 控制算法**：
     - CPU 控制不像内存那么精确，通过调整工作时间和睡眠时间的比例来实现
     - 按 CPU 核心数启动对应数量的协程
     - 每个协程内包含耗 CPU 的算法 + sleep 函数
     - 调大 sleep 值 = 释放 CPU（降低占用）
     - 调小 sleep 值 = 更耗 CPU（提高占用）
     - **sleep 值调整**：
       - sleep 值范围：1ms - 100ms
       - 每次调整步长：5ms
       - **概率计算**（与内存控制算法相同）：
         - 如果当前整机 CPU 占用 > 期望占用：高概率调大 sleep 值（降低占用）
         - 如果当前整机 CPU 占用 < 期望占用：高概率调小 sleep 值（提高占用）
         - 如果当前整机 CPU 占用接近期望占用：调小 sleep 的概率略大于调大的概率

3. **时区感知**：
   - 程序运行在容器环境中，容器时区为 0 时区（UTC）
   - 程序运行在中国，需要根据 UTC 时间判断中国时间
   - **凌晨时段**（UTC 16:00-20:00，对应中国 0:00-4:00）：可以完全按照期望的 CPU 和内存占用
   - **其他时段**：只能占用期望值的 80%（8折）

4. **峰值控制**：
   - 使用环境变量 `P` 或 `p` 进行峰值控制（整个机器的使用率百分比，不区分大小写）
   - 默认值：40%
   - **硬峰值限制**：70%（任何时段都不能超过 70%，保证其他应用的正常使用）
   - **安全机制**：如果当前 CPU 或内存占用超过 70%，程序会**强制降低**（不随机），避免系统宕机风险
   - **示例**：
     - 用户设置 `P=70`：
       - 凌晨时段：可到 70%（不超过硬峰值）
       - 其他时段：可到 56%（70% * 0.8）
     - 用户设置 `P=90`：
       - 凌晨时段：可到 70%（不超过硬峰值）
       - 其他时段：可到 70%（90% * 0.8 = 72%，但不超过硬峰值 70%）

5. **资源占用方式**：
   - **内存**：动态分配/释放，根据算法概率性地调整内存大小，每隔 1 分钟触发一次 GC 确保内存及时回收
   - **CPU**：按 CPU 核心数启动对应数量的协程，每个协程通过工作+睡眠的方式控制占用，实现多核均衡占用，不能把某一个核心全部吃完

## 环境变量

- `P` 或 `p`：峰值使用率百分比（不区分大小写，默认：40）
  - 示例：`P=70` 或 `p=70` 表示期望整机使用率达到 70%
  - 取值范围：1-100，超出范围或无效值将使用默认值 40%

## 注意事项和风险点

### 1. 资源监控
- 程序需要定期获取整机的 CPU 和内存占用率
- 监控频率需要平衡准确性和性能影响（建议每 5-10 秒监控一次）
- 如果获取系统资源信息失败，程序应降级处理或使用上次的有效值

### 2. 内存控制细节
- **0.1% 的基准**：每次调整 0.1% 是指整机总内存的 0.1%
- **内存分配失败**：如果系统内存不足，程序应停止增加内存占用，并记录日志
- **内存释放**：内存释放是异步的，可能不会立即生效，需要考虑延迟
- **垃圾回收（GC）**：为了及时释放内存，程序每隔 1 分钟手动触发一次 `runtime.GC()`，确保内存能够及时回收

### 3. CPU 控制细节
- **sleep 值范围**：需要定义 sleep 的最小值和最大值，避免极端情况
- **CPU 核心数获取**：如果获取 CPU 核心数失败，应使用默认值（如 4 核）或降级处理
- **耗 CPU 算法**：使用简单的计算密集型算法（如循环计算），避免复杂操作影响系统

### 4. 时区处理
- 程序运行在容器环境中，容器时区固定为 0 时区（UTC），无需担心时区配置问题
- 直接使用 `time.Now().UTC()` 获取 UTC 时间进行判断即可

### 5. 错误处理和容错
- 如果系统资源监控失败，程序应继续运行但使用保守策略（降低占用）
- **硬峰值安全机制**：如果当前 CPU 或内存占用超过 70%，程序会立即强制降低（不随机），并记录 WARN 级别日志，避免系统宕机风险
- 程序应记录关键操作日志，便于排查问题
  - **日志库**：使用 Go 标准库 `log/slog` 进行日志记录
  - **日志输出**：标准输出（stdout），便于容器日志收集，不写文件
  - **日志级别**：INFO（正常操作）、WARN（警告，如超过硬峰值）、ERROR（错误）
  - **日志内容**：
    1. **每次获取系统资源信息时（每 5-10 秒）**：打印当前整机 CPU 和内存占用率、期望占用值、当前时段（凌晨/其他）
    2. **每次随机调整时**：打印 rand 结果，明确说明是**增加资源**还是**减少资源**，以及调整的具体数值（内存调整量或 CPU count 值变化）
    3. **硬峰值警告**：当占用超过 70% 时，打印 WARN 级别日志，说明强制降低操作
    4. **错误信息**：系统资源监控失败、内存分配失败等错误情况
- 考虑添加优雅退出机制（如接收 SIGTERM/SIGINT 信号），退出前释放所有资源

### 6. 边界情况
- **极低配置机器**：如果机器内存或 CPU 很少，程序应检测并降低占用
- **极低期望值**：如果用户设置期望值过低（如 1%），程序应设置最小值（如 5%）
- **资源竞争**：如果其他应用突然占用大量资源，程序应快速响应并降低占用

### 7. 程序自身资源消耗
- 程序本身的 CPU 和内存占用应尽可能小
- 监控和调整操作不应成为系统负担

### 8. 部署和运行
- 程序运行在容器环境中
- 容器时区固定为 0 时区（UTC）
- 程序不需要 root 权限即可运行
- 建议使用 Docker/Kubernetes 等容器编排工具部署
- **启动方式**：直接运行编译后的二进制文件，程序会持续运行直到收到退出信号
- **资源监控**：程序需要读取 `/proc` 目录（Linux）或使用系统 API 获取 CPU 和内存使用情况 
